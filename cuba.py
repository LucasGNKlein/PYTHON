# -*- coding: utf-8 -*-
"""cuba.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YuGkSbrXVBfksZs3SmURSwxDDS92tc37
"""

!pip install pycuda matplotlib numpy
#!apt-get install -y ffmpeg

import numpy as np
import matplotlib.pyplot as plt
import time
import pycuda.autoinit
import pycuda.driver as drv
from pycuda.compiler import SourceModule

!nvidia-smi

#parrmetros

NUM_INDIVIDUOS = 100
NUM_PASSOS = 30
NUM_GERACOES = 50
TAXA_MUTACAO = 0.1
LIMITE_X = 6.0
LIMITE_Y = 6.0

ALVO = np.array([5.0, 5.0], dtype=np.float32)

OBSTACULOS = np.array([
    [1.5, 1.0, 2.5, 2.0],
    [3.0, 2.5, 4.0, 3.5],
    [2.0, 4.0, 3.0, 5.0]
], dtype=np.float32)

# FUNÇÕES AUXILIARES

def inicializar_populacao():
    posicoes = np.random.uniform(0, 0.5, size=(NUM_INDIVIDUOS, 2)).astype(np.float32)
    genes = np.random.uniform(-0.2, 0.2, size=(NUM_INDIVIDUOS, NUM_PASSOS, 2)).astype(np.float32)
    return posicoes, genes


def mover_criaturas(posicoes, genes):
    trajetorias = np.zeros((NUM_INDIVIDUOS, NUM_PASSOS+1, 2), dtype=np.float32)
    trajetorias[:, 0] = posicoes

    for i in range(NUM_PASSOS):
        novas_pos = trajetorias[:, i] + genes[:, i]

        #reação colisão
        for j in range(NUM_INDIVIDUOS):
            x, y = novas_pos[j]
            for ox, oy, ex, ey in OBSTACULOS:
                if ox <= x <= ex and oy <= y <= ey:
                    #repulsão
                    dx, dy = np.random.uniform(-1, 1, 2)
                    novas_pos[j, 0] += dx * 0.3
                    novas_pos[j, 1] += dy * 0.3
                    #limitar dentro da area
                    novas_pos[j, 0] = np.clip(novas_pos[j, 0], 0, LIMITE_X)
                    novas_pos[j, 1] = np.clip(novas_pos[j, 1], 0, LIMITE_Y)
        trajetorias[:, i+1] = novas_pos

    return trajetorias

# FITNESS CPU
def calcular_fitness_cpu(trajetorias):
    fitness = np.zeros(NUM_INDIVIDUOS, dtype=np.float32)
    for idx in range(NUM_INDIVIDUOS):
        x, y = trajetorias[idx, -1]
        dx, dy = ALVO - np.array([x, y])
        dist = np.sqrt(dx**2 + dy**2)
        fitness[idx] = 1.0 / (1.0 + dist)
    return fitness

# FITNESS GPU
mod = SourceModule("""
__device__ bool colide(float x, float y, float *obstaculos, int num_obs) {
    for (int i = 0; i < num_obs; i++) {
        float xmin = obstaculos[i*4];
        float ymin = obstaculos[i*4 + 1];
        float xmax = obstaculos[i*4 + 2];
        float ymax = obstaculos[i*4 + 3];
        if (x >= xmin && x <= xmax && y >= ymin && y <= ymax)
            return true;
    }
    return false;
}

__global__ void avaliar(float *trajetorias, float *fitness, float *alvo, float *obstaculos, int num_obs, int num_ind, int num_passos) {
    int idx = threadIdx.x + blockIdx.x * blockDim.x;
    if (idx >= num_ind) return;

    float x = 0.0;
    float y = 0.0;

    for (int i = 0; i < num_passos + 1; i++) {
        x = trajetorias[idx*(num_passos+1)*2 + i*2];
        y = trajetorias[idx*(num_passos+1)*2 + i*2 + 1];
        if (colide(x, y, obstaculos, num_obs)) {
            // Reação simples: leve empurrão (simulação GPU)
            x += ((float)(i % 3) - 1.0f) * 0.2f;
            y += ((float)((i+1) % 3) - 1.0f) * 0.2f;
        }
    }

    float dx = alvo[0] - x;
    float dy = alvo[1] - y;
    float dist = sqrtf(dx*dx + dy*dy);
    fitness[idx] = 1.0 / (1.0 + dist);
}
""")

avaliar_fitness = mod.get_function("avaliar")

def calcular_fitness_gpu(trajetorias):
    fitness = np.zeros(NUM_INDIVIDUOS, dtype=np.float32)
    avaliar_fitness(
        drv.In(trajetorias),
        drv.Out(fitness),
        drv.In(ALVO),
        drv.In(OBSTACULOS),
        np.int32(OBSTACULOS.shape[0]),
        np.int32(NUM_INDIVIDUOS),
        np.int32(NUM_PASSOS),
        block=(128,1,1),
        grid=(int(np.ceil(NUM_INDIVIDUOS/128)),1)
    )
    return fitness

# GENÉTICA

def selecionar(populacao, fitness):
    idx = np.argsort(fitness)[::-1]
    return idx[:int(0.2 * NUM_INDIVIDUOS)]


def crossover(genes, elite_idx):
    novos_genes = []
    elite = genes[elite_idx]
    while len(novos_genes) < NUM_INDIVIDUOS:
        p1, p2 = elite[np.random.randint(len(elite), size=2)]
        ponto = np.random.randint(NUM_PASSOS)
        filho = np.vstack((p1[:ponto], p2[ponto:]))
        novos_genes.append(filho)
    return np.array(novos_genes[:NUM_INDIVIDUOS], dtype=np.float32)


def mutar(genes):
    mask = np.random.rand(*genes.shape) < TAXA_MUTACAO
    genes += mask * np.random.uniform(-0.1, 0.1, size=genes.shape).astype(np.float32)
    return genes

#SIMULAÇÃO

def simular(nome, usar_gpu=False):
    posicoes, genes = inicializar_populacao()
    historico_melhor, historico_media = [], []

    t0 = time.time()
    for geracao in range(NUM_GERACOES):
        trajetorias = mover_criaturas(posicoes, genes)
        fitness = calcular_fitness_gpu(trajetorias) if usar_gpu else calcular_fitness_cpu(trajetorias)

        melhor = np.max(fitness)
        media = np.mean(fitness)
        historico_melhor.append(melhor)
        historico_media.append(media)

        elite_idx = selecionar(genes, fitness)
        genes = crossover(genes, elite_idx)
        genes = mutar(genes)
        posicoes = np.random.uniform(0, 0.5, size=(NUM_INDIVIDUOS, 2)).astype(np.float32)

    tempo = time.time() - t0
    print(f"{nome} concluído em {tempo:.3f}s")
    return historico_melhor, historico_media, tempo

# EXECUÇÃO: CPU vs GPU

print("Executando na CPU...")
melhor_cpu, media_cpu, tempo_cpu = simular("CPU", usar_gpu=False)

print("\nExecutando na GPU...")
melhor_gpu, media_gpu, tempo_gpu = simular("GPU", usar_gpu=True)

# COMPARAÇÃO

plt.figure(figsize=(10,5))

plt.subplot(1,2,1)
plt.plot(melhor_cpu, label="Melhor (CPU)", color='red')
plt.plot(media_cpu, label="Média (CPU)", color='orange')
plt.plot(melhor_gpu, label="Melhor (GPU)", color='blue')
plt.plot(media_gpu, label="Média (GPU)", color='cyan')
plt.title("Evolução da Aptidão")
plt.xlabel("Geração")
plt.ylabel("Fitness")
plt.legend()
plt.grid(True)

plt.subplot(1,2,2)
plt.bar(["CPU", "GPU"], [tempo_cpu, tempo_gpu], color=['red', 'blue'])
plt.title("Tempo total de execução")
plt.ylabel("Segundos")

plt.suptitle("Comparação de desempenho: GPU x CPU (com desvio instintivo)", fontsize=14)
plt.tight_layout()
plt.show()

def visualizar_trajetorias(trajetorias, titulo="Movimento das Criaturas"):
    plt.figure(figsize=(6,6))
    plt.title(titulo)
    plt.xlabel("X")
    plt.ylabel("Y")
    plt.xlim(0, LIMITE_X)
    plt.ylim(0, LIMITE_Y)
    plt.grid(True)

    # Obstáculos (retângulos)
    for ox, oy, ex, ey in OBSTACULOS:
        plt.fill([ox, ex, ex, ox], [oy, oy, ey, ey], color='gray', alpha=0.5, label="Obstáculo")

    # Alvo
    plt.scatter(ALVO[0], ALVO[1], color='green', s=100, marker='X', label="Alvo")

    # Trajetórias das criaturas
    for i in range(min(20, NUM_INDIVIDUOS)):  # mostra até 20 criaturas pra não poluir
        plt.plot(trajetorias[i, :, 0], trajetorias[i, :, 1], alpha=0.6)

    plt.legend(loc="upper left")
    plt.show()